== Getting Started
To see what Spring Shell has to offer, we can write a trivial shell application that
has a simple command to add two numbers.

IMPORTANT: _Spring Shell_ is based on _Spring Boot_ {spring-boot-version} and
_Spring Framework_ {spring-version} and thus requires _JDK 17_.

=== Writing a Simple Shell Application

For the purpose of this tutorial, we create a simple Spring Boot application by
using https://start.spring.io where you can choose _Spring Shell_ dependency.
This minimal application depends only on `spring-boot-starter` and
`spring-shell-starter`.

NOTE: _Spring Shell_ version on `start.spring.io` is usually latest release.

With _maven_ you're expected to have something like:

====
[source, xml, subs=attributes+]
----
<properties>
    <spring-shell.version>{project-version}</spring-shell.version>
</properties>

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-shell-starter</artifactId>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.shell</groupId>
            <artifactId>spring-shell-dependencies</artifactId>
            <version>${spring-shell.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
----
====

With _gradle_ you're expected to have something like:

====
[source, groovy, subs=attributes+]
----
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    implementation 'org.springframework.shell:spring-shell-starter'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.shell:spring-shell-dependencies:{project-version}"
    }
}
----
====

CAUTION: Given that Spring Shell starts the REPL (Read-Eval-Print-Loop) because this
dependency is present, you need to either skip tests when you build (`-DskipTests`)
throughout this tutorial or remove the sample integration test that was generated
by https://start.spring.io. If you do not remove it, the integration test creates
the Spring `ApplicationContext` and, depending on your build tool, stays stuck in
the eval loop or crashes with a NPE.

Once compiled it can be run either in interactive mode:

====
[source, text, subs=attributes+]
----
include::code/getting-started-run-interactive.out[]
----
====

Or in non-interactive mode:

====
[source, text, subs=attributes+]
----
include::code/getting-started-run-noninteractive.out[]
----
====

TIP: Check out <<using-shell-customization-logging>> making logging to work
better with shell apps.

[[using-spring-shell-your-first-command]]
=== Your First Command

Now we can add our first command. To do so, create a new class (named whatever you want) and
annotate it with `@ShellComponent` (a variation of `@Component` that is used to restrict
the set of classes that are scanned for candidate commands).

Then we can create an `add` method that takes two ints (`a` and `b`) and returns their sum. We need to annotate it
with `@ShellMethod` and provide a description of the command in the annotation (the only piece of
information that is required):

====
[source, java]
----
package com.example.demo;

import org.springframework.shell.standard.ShellMethod;
import org.springframework.shell.standard.ShellComponent;

@ShellComponent
public class MyCommands {

    @ShellMethod("Add two integers together.")
    public int add(int a, int b) {
        return a + b;
    }
}
----
====

New _add_ command becomes visible to _help_:

====
[source, text]
----
My Commands
       add: Add two integers together.
----
====

And you can run it:

====
[source, text]
----
shell:>add --a 1 --b 2
3
----
====

The rest of this document delves deeper into the whole Spring Shell programming model.
